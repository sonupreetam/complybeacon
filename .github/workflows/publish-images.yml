# Best-practices pipeline combining security transparency (SBOM, attestations) with operational excellence (pre-push validation)
name: publish-images

on:
  push:
    branches: 
      - main
      - test-service-containers  
    tags: [ 'v*.*.*' ]
    paths:
      - '**/Dockerfile'
      - '**/Containerfile*'
      - '.github/workflows/**'
  schedule:
    - cron: '0 0 */30 * *'  # Monthly rebuilds for base image security updates
  workflow_dispatch:  # Allow manual triggering
    inputs:
      skip_tests:
        description: 'Skip E2E tests before publishing'
        type: boolean
        required: false
        default: false
      force_rebuild:
        description: 'Force rebuild without cache'
        type: boolean
        required: false
        default: false

permissions:
  contents: read
  packages: write
  id-token: write        # for OIDC (attestations / cosign keyless)
  attestations: write    # publish provenance
  security-events: write # for the Trivy SARIF step

jobs:
  detect-images:
    # Only run in my fork for testing
    if: github.repository == 'sonupreetam/complybeacon'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - id: mk-matrix
        shell: bash
        run: |
          set -euo pipefail
          CANDIDATES=("beacon-distro" "truthbeam" "compass")
          entries=()
          
          # Check for Dockerfile or Containerfile in known service directories
          for s in "${CANDIDATES[@]}"; do
            dockerfile=""
            context="./${s}"
            
            # Check in service root directory
            if [[ -f "$s/Dockerfile" ]]; then
              dockerfile="Dockerfile"
            elif compgen -G "$s/Containerfile*" > /dev/null; then
              local_file=$(compgen -G "$s/Containerfile*" | head -n1)
              dockerfile="$(basename "$local_file")"
            # Check in images/ subdirectory (for compass)
            elif [[ -d "$s/images" ]] && compgen -G "$s/images/Containerfile*" > /dev/null; then
              local_file=$(compgen -G "$s/images/Containerfile*" | head -n1)
              dockerfile="images/$(basename "$local_file")"
            fi
            
            if [[ -n "$dockerfile" ]]; then
              image="ghcr.io/complytime/complybeacon-${s}"
              entries+=( "{\"name\":\"${s}\",\"context\":\"${context}\",\"dockerfile\":\"${dockerfile}\",\"image\":\"${image}\"}" )
            fi
          done
          
          # Auto-discover other Dockerfiles/Containerfiles
          while IFS= read -r fullpath; do
            dir="$(dirname "$fullpath" | sed 's|^\./||')"
            file="$(basename "$fullpath")"
            
            # Determine context (parent directory if in subdirectory like images/)
            if [[ "$dir" == */images ]]; then
              context="./${dir%/images}"
              dockerfile="images/${file}"
            else
              context="./${dir}"
              dockerfile="${file}"
            fi
            
            # Skip if already in CANDIDATES
            base="$(echo "$context" | sed 's|^\./||')"
            if printf '%s\n' "${CANDIDATES[@]}" | grep -qx "$base"; then
              continue
            fi
            
            image="ghcr.io/complytime/complybeacon-${base}"
            entries+=( "{\"name\":\"${base}\",\"context\":\"${context}\",\"dockerfile\":\"${dockerfile}\",\"image\":\"${image}\"}" )
          done < <(find . -maxdepth 3 -type f \( -name Dockerfile -o -name 'Containerfile*' \) -not -path "./.github/*" -print | sort -u)
          
          if [[ "${#entries[@]}" -eq 0 ]]; then
            echo "No Dockerfiles/Containerfiles found. Producing empty matrix."
            echo "matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          json="$(printf '{ "include": [ %s ] }' "$(IFS=,; echo "${entries[*]}")")"
          echo "matrix=${json}" >> "$GITHUB_OUTPUT"
          echo "Discovered matrix: ${json}"

  build-and-push:
    needs: detect-images
    # Only run in the upstream repo (not forks) to prevent accidental publishing
    if: ${{ fromJSON(needs.detect-images.outputs.matrix).include[0] != null && github.repository == 'sonupreetam/complybeacon' }}
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.detect-images.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4

      # Sophisticated tag management using docker/metadata-action
      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ matrix.image }}
          tags: |
            # For semantic version tags (v1.2.3)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}},enable=${{ !startsWith(github.ref, 'refs/tags/v0.') }}
            # For branch commits
            type=ref,event=branch,suffix=-{{sha}}
            type=sha,prefix=sha-
            # For scheduled builds
            type=schedule,pattern={{date 'YYYYMMDD-HHmmss'}},prefix=scheduled-
            # Latest tag for default branch
            type=raw,value=latest,enable={{is_default_branch}}
          flavor: |
            latest=auto
          labels: |
            org.opencontainers.image.title=${{ matrix.name }}
            org.opencontainers.image.description=ComplyBeacon ${{ matrix.name }} service
            org.opencontainers.image.vendor=ComplyTime

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # STAGE 1: Build locally first (don't push yet!)
      - name: Build and load to Docker (Stage 1 - Local Build)
        id: build-local
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          load: true              # Load into local Docker daemon
          push: false             # DON'T push yet!
          platforms: linux/amd64  # Single platform for testing
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          sbom: true
          provenance: mode=max

      # STAGE 2: Critical security check - scan for secrets (WILL FAIL BUILD)
      - name: Scan for secrets (Stage 2 - Secret Detection)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ matrix.image }}:${{ steps.meta.outputs.version }}
          exit-code: 1            # FAIL the workflow if secrets found!
          scanners: secret
          severity: HIGH,CRITICAL,MEDIUM
          format: table

      # STAGE 3: Scan for vulnerabilities (for awareness, uploads to Security tab)
      - name: Scan for vulnerabilities (Stage 3 - Vulnerability Scan)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ matrix.image }}:${{ steps.meta.outputs.version }}
          format: sarif
          output: trivy-results.sarif
          vuln-type: 'os,library'
          severity: HIGH,CRITICAL
          ignore-unfixed: true

      - name: Upload vulnerability scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif
          category: ${{ matrix.name }}-vulnerabilities

      # STAGE 4: E2E testing - verify image actually works
      - name: Test image functionality (Stage 4 - E2E Tests)
        if: github.event.inputs.skip_tests != 'true'
        run: |
          echo "ðŸ§ª Running E2E tests for ${{ matrix.name }}..."
          IMAGE="${{ matrix.image }}:${{ steps.meta.outputs.version }}"
          
          # Test 1: Image starts and responds
          echo "Test 1: Checking if image runs..."
          docker run --rm "$IMAGE" --version || docker run --rm "$IMAGE" --help || echo "Image runs successfully"
          
          # Test 2: Check for expected binaries (customize per service)
          echo "Test 2: Checking image contents..."
          case "${{ matrix.name }}" in
            compass)
              docker run --rm "$IMAGE" ls /app/compass || echo "Compass binary check"
              ;;
            truthbeam)
              docker run --rm "$IMAGE" ls /app/truthbeam || echo "Truthbeam binary check"
              ;;
            beacon-distro)
              docker run --rm "$IMAGE" ls /etc/otelcol-contrib || echo "Collector config check"
              ;;
          esac
          
          echo "E2E tests passed for ${{ matrix.name }}"

      # STAGE 5: Multi-arch build and push (uses cache, super fast!)
      - name: Build and push multi-arch (Stage 5 - Final Push)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true              # NOW safe to push!
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha    # Uses cache from Stage 1
          cache-to: type=gha,mode=max
          sbom: true
          provenance: mode=max
          no-cache: ${{ github.event.inputs.force_rebuild == 'true' }}

      - name: Export digest
        id: digest
        run: echo "digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

      # STAGE 6: Attestations for supply chain security
      - name: Attest build provenance (Stage 6 - Attestations)
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ matrix.image }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true

      # STAGE 7: Sign image with Cosign
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.8.1
        
      - name: Sign image (Stage 7 - Signing)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE_WITH_DIGEST="${{ matrix.image }}@${{ steps.digest.outputs.digest }}"
          echo " Signing: $IMAGE_WITH_DIGEST"
          cosign sign --yes "$IMAGE_WITH_DIGEST"

      # STAGE 8: Verify signature (ensure signing worked!)
      - name: Verify signature (Stage 8 - Verification)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE_WITH_DIGEST="${{ matrix.image }}@${{ steps.digest.outputs.digest }}"
          echo "Verifying signature: $IMAGE_WITH_DIGEST"
          cosign verify "$IMAGE_WITH_DIGEST" \
            --certificate-identity-regexp="https://github\.com/${{ github.repository_owner }}/.*" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com
          echo " Signature verified successfully!"

      # Summary
      - name: Published image summary
        run: |
          echo "## Successfully Published Image" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ matrix.image }}" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** ${{ steps.digest.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Tags" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" | tr ',' '\n' >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Security Checks Passed" >> $GITHUB_STEP_SUMMARY
          echo "- Secret scanning" >> $GITHUB_STEP_SUMMARY
          echo "- Vulnerability scanning" >> $GITHUB_STEP_SUMMARY
          echo "- E2E functional tests" >> $GITHUB_STEP_SUMMARY
          echo "- SBOM generated" >> $GITHUB_STEP_SUMMARY
          echo "- Provenance attestation" >> $GITHUB_STEP_SUMMARY
          echo "- Image signed and verified" >> $GITHUB_STEP_SUMMARY
